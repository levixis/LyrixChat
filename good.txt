import os
import re
import json
import logging
from flask import Flask, render_template, request, jsonify, session
import requests
from bs4 import BeautifulSoup
import spotipy
from spotipy.oauth2 import SpotifyClientCredentials
import google.generativeai as genai
from flask_cors import CORS
from thefuzz import fuzz
from dotenv import load_dotenv
load_dotenv()


# --- Basic Setup ---
app = Flask(__name__)
app.secret_key = os.urandom(24) # Needed for session memory
CORS(app)
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# --- API Credentials ---
GENIUS_ACCESS_TOKEN = os.getenv('GENIUS_ACCESS_TOKEN')
SPOTIFY_CLIENT_ID = os.getenv('SPOTIFY_CLIENT_ID')
SPOTIFY_CLIENT_SECRET = os.getenv('SPOTIFY_CLIENT_SECRET')
GEMINI_API_KEY = os.getenv('GEMINI_API_KEY')

# --- API Client Initialization ---
try:
    sp = spotipy.Spotify(auth_manager=SpotifyClientCredentials(client_id=SPOTIFY_CLIENT_ID, client_secret=SPOTIFY_CLIENT_SECRET))
    genai.configure(api_key=GEMINI_API_KEY)
    gemini_model = genai.GenerativeModel('gemini-1.5-flash-latest')
except Exception as e:
    logging.error(f"Failed to initialize API clients: {e}")
    sp = None
    gemini_model = None

def interpret_user_request(user_query):
    # This prompt is working perfectly.
    prompt = f"""
    You are an expert music query interpreter. Analyze the user's request and classify it.
    Your main job is to correct spelling mistakes in song titles, artist names, AND lyric snippets to find the correct match.
    Your response MUST be a single, valid JSON object.

    1. If the request is a song title and/or artist, classify as 'title_search'.
       - Example: "hottel califfornia by egles" -> {{"type": "title_search", "title": "Hotel California", "artist": "Eagles"}}
       - Example: "udariyaaan" -> {{"type": "title_search", "title": "Udaarian", "artist": null}}

    2. If the request is a snippet of lyrics, classify as 'lyrics_search'.
       - Example: "blending lits" -> {{"type": "lyrics_search", "lyrics_snippet": "Blinding Lights"}}

    3. If the request is a greeting or help request, classify as 'intent'.
       - Example: "hello there" -> {{"type": "intent", "value": "greeting"}}

    Analyze this user query: "{user_query}"
    """
    try:
        response = gemini_model.generate_content(prompt)
        cleaned_text = response.text.strip().replace("```json", "").replace("```", "").strip()
        logging.info(f"Gemini interpretation: {cleaned_text}")
        return json.loads(cleaned_text)
    except Exception as e:
        logging.error(f"Gemini interpretation error: {e}")
        return {"type": "intent", "value": "unclear"}


def search_genius(song_name, artist_name=None):
    """Searches Genius with a high-quality query and uses nuanced validation."""
    headers = {'Authorization': f'Bearer {GENIUS_ACCESS_TOKEN}'}
    search_term = f"{song_name} {artist_name}" if artist_name else song_name
    params = {'q': search_term}
    logging.info(f"Attempting search with term: '{search_term}'")
    
    try:
        response = requests.get('https://api.genius.com/search', headers=headers, params=params)
        response.raise_for_status()
        data = response.json()
        
        best_hit = None
        highest_score = 0
        
        for hit in data.get('response', {}).get('hits', []):
            if hit.get('type') == 'song':
                result = hit['result']
                genius_title = result.get('title', '').lower()
                genius_artist = result.get('primary_artist', {}).get('name', '').lower()

                # === THE DEFINITIVE FIX: USE THE RIGHT TOOL FOR EACH JOB ===
                # Use a strict ratio for the title
                title_score = fuzz.WRatio(song_name.lower(), genius_title)
                
                # Use a flexible ratio for the artist to handle partial names
                artist_score = 100
                if artist_name:
                    artist_score = fuzz.token_set_ratio(artist_name.lower(), genius_artist)
                
                # We require a very high artist match if one was provided
                if artist_name and artist_score < 85:
                    continue
                
                total_score = (title_score * 0.6) + (artist_score * 0.4)
                if total_score > highest_score:
                    highest_score = total_score
                    best_hit = result

        if best_hit and highest_score > 85:
            logging.info(f"Found match '{best_hit.get('title')}' with score {highest_score}")
            cover_art = best_hit.get('song_art_image_thumbnail_url') or best_hit.get('header_image_thumbnail_url') or ''
            return {'url': best_hit.get('url'), 'title': best_hit.get('title'), 'artist': best_hit.get('primary_artist', {}).get('name'), 'cover_art': cover_art}
        
        logging.warning(f"No satisfactory match found. Highest validation score was {highest_score}")
        return None
    except Exception as e:
        logging.error(f"Genius API error: {e}")
        return None

# (No changes to scrape_lyrics or search_spotify_track)
def scrape_lyrics(url):
    try:
        response = requests.get(url, headers={'User-Agent': 'Mozilla/5.0'})
        soup = BeautifulSoup(response.text, 'html.parser')
        lyrics_containers = soup.select("div[data-lyrics-container='true']")
        if not lyrics_containers: return "Lyrics could not be scraped."
        lyrics_html = "".join(container.decode_contents() for container in lyrics_containers)
        lyrics_text = re.sub(r'<br/?>', '\n', lyrics_html)
        lyrics_text = re.sub(r'<.*?>', '', lyrics_text)
        return lyrics_text.strip()
    except Exception as e:
        logging.error(f"Lyrics scraping error: {e}")
        return "Could not retrieve lyrics."

def search_spotify_track(song_name, artist_name=None):
    if not sp: return {}
    try:
        query = f'track:{song_name} artist:{artist_name}' if artist_name else f'track:{song_name}'
        results = sp.search(q=query, type='track', limit=1)
        if tracks := results['tracks']['items']:
            track = tracks[0]
            return {'album_art': track['album']['images'][0]['url'] if track['album']['images'] else None, 'preview_url': track.get('preview_url'), 'spotify_url': track['external_urls']['spotify']}
        return {}
    except Exception as e:
        logging.error(f"Spotify error: {e}")
        return {}


@app.route('/')
def index():
    return render_template('index.html')


@app.route('/chat', methods=['POST'])
def handle_chat():
    message = request.form.get('message', '').strip()
    if not message:
        return jsonify({'type': 'error', 'content': 'Please enter a message!'})
    
    logging.info(f"Received user message: '{message}'")
    genius_data = None
    display_name = message # Default display name for errors

    if 'pending_artist_for_title' in session:
        song_name = session.pop('pending_artist_for_title')
        artist_name = message # The user's new message is the artist name
        display_name = f"{song_name} by {artist_name}"
        logging.info(f"Received artist '{artist_name}' for pending title '{song_name}'")
        genius_data = search_genius(song_name, artist_name)
    else:
        parsed_request = interpret_user_request(message)
        request_type = parsed_request.get('type')
        
        if request_type == 'title_search':
            song_name = parsed_request.get('title')
            artist_name = parsed_request.get('artist')
            display_name = song_name or message
            
            if song_name and artist_name:
                genius_data = search_genius(song_name, artist_name)
            elif song_name:
                logging.info(f"Ambiguity detected for title '{song_name}'. Asking for artist.")
                session['pending_artist_for_title'] = song_name
                return jsonify({'type': 'message', 'content': f"To make sure I get the right one, who is the artist for '{song_name}'?"})

        elif request_type == 'lyrics_search':
            lyrics_snippet = parsed_request.get('lyrics_snippet')
            display_name = lyrics_snippet or message
            if lyrics_snippet:
                genius_data = search_genius(song_name=lyrics_snippet)

        elif request_type == 'intent':
            session.pop('pending_artist_for_title', None)
            return jsonify({'type': 'message', 'content': 'I can find lyrics for you! Just type a song name.'})

    if not genius_data:
        return jsonify({'type': 'error', 'content': f"Sorry, I couldn't find a match for '{display_name}'."})

    lyrics = scrape_lyrics(genius_data['url'])
    spotify_data = search_spotify_track(genius_data['title'], genius_data['artist'])
    album_art = spotify_data.get('album_art') or genius_data.get('cover_art')

    return jsonify({
        'type': 'lyrics',
        'title': genius_data['title'],
        'artist': genius_data['artist'],
        'content': lyrics or 'Lyrics unavailable.',
        'album_art': album_art,
        'preview_url': spotify_data.get('preview_url'),
        'spotify_url': spotify_data.get('spotify_url')
    })

if __name__ == '__main__':
    port = int(os.environ.get('PORT', 5000))
    app.run(host='0.0.0.0', port=port, debug=True)